import Erdos.Basic

namespace Erdos

namespace BlockModel

/-!
### “No carry enters” helper lemmas

These are small arithmetic facts about `concatWithCarryTrace` that correspond to the manuscript’s
boundary conditions (notably `\kappa_K = 0`) and the local slogan “this block is carry-free”.
-/

/-- The last carry in the carry trace is always `0` (the initialization `κ_K = 0`). -/
theorem concatWithCarryTrace_carries_get_last_eq_zero
  (b L baseBlock : ℕ) (ps : List ℕ) :
  let carries := (concatWithCarryTrace b L baseBlock ps).2.2
  carries[ps.length]'
    (by
      have hc : carries.length = ps.length + 1 :=
      concatWithCarryTrace_carries_length (b := b) (L := L) (baseBlock := baseBlock) ps
      -- `ps.length < carries.length`.
      simpa [hc] using Nat.lt_succ_self ps.length)
    = 0 := by
  induction ps with
  | nil =>
    simp [concatWithCarryTrace]
  | cons p ps ih =>
    -- Unfold one step of the trace; the carry list is `κ' :: carriesTail`.
    -- The last element is the last element of `carriesTail`.
    simp [concatWithCarryTrace_cons, ih]

/--
If the most-significant block does not overflow, then the *outgoing* carry `κ₀` is `0`.

In manuscript terms: “the first block does not generate a carry into the integer part”.

This is *not automatic* from the construction; it is a separate boundary smallness condition.
-/
theorem concatWithCarryTrace_carry0_cons_eq_zero_of_lt_blockBase
    (b L baseBlock p : ℕ) (ps : List ℕ)
    (h : baseBlock + p + (concatWithCarryTrace b L baseBlock ps).1 < blockBase b L) :
    (concatWithCarryTrace b L baseBlock (p :: ps)).1 = 0 := by
  -- Unfold the head carry recurrence and use `Nat.div_eq_of_lt`.
  have : (baseBlock + p + (concatWithCarryTrace b L baseBlock ps).1) / blockBase b L = 0 :=
    Nat.div_eq_of_lt h
  simpa [concatWithCarryCarry_cons] using this

/--
The first carry in the carry list is the outgoing carry `κ₀`.

This is a tiny adapter lemma so you can talk about “carry generated by the first block”
using the indexed carry list.
-/
theorem concatWithCarryTrace_carries_get0_eq_carry0
    (b L baseBlock : ℕ) (ps : List ℕ)
    (h : 0 < (concatWithCarryTrace b L baseBlock ps).2.2.length) :
    (concatWithCarryTrace b L baseBlock ps).2.2[0]'h =
      (concatWithCarryTrace b L baseBlock ps).1 :=
  concatWithCarryTrace_carries_getElem0 (b := b) (L := L) (baseBlock := baseBlock) (ps := ps) h

/--
If the incoming carry into a block is zero, then the output block is just the naive sum reduced
modulo the block base.

This is the Lean analogue of the manuscript slogan “no carry enters this block, so the block is
cleanly aligned”.
-/
theorem concatWithCarryBlocks_get_of_carryNext_eq_zero
    (b L baseBlock : ℕ) (ps : List ℕ) (i : Fin ps.length)
    (hnext :
      let carries := (concatWithCarryTrace b L baseBlock ps).2.2
      carries[i.1 + 1]'
          (by
            have hc : carries.length = ps.length + 1 :=
              concatWithCarryTrace_carries_length (b := b) (L := L) (baseBlock := baseBlock) ps
            -- `i.1 + 1 < carries.length`.
            simpa [hc] using Nat.succ_lt_succ i.isLt) = 0) :
    (concatWithCarryBlocks b L baseBlock ps).get
        ⟨i.1, by
          have hl : (concatWithCarryBlocks b L baseBlock ps).length = ps.length :=
            concatWithCarryBlocks_length (b := b) (L := L) (baseBlock := baseBlock) ps
          simp [hl]⟩
      = (baseBlock + ps.get i) % blockBase b L := by
  classical
  -- Start from the per-index block recurrence and simplify the carry term.
  -- Unfold the `let`-bindings in both the recurrence and `hnext`.
  have h :=
    concatWithCarryBlocks_get (b := b) (L := L) (baseBlock := baseBlock) (ps := ps) i
  -- `simp` with `hnext` kills the carry term; remaining goal is reassociating `+`.
  -- (The recurrence is stated as `baseBlock + ps.get i + carryNext`, but simp may rewrite as
  -- `baseBlock + (ps.get i + carryNext)`.)
  simpa [hnext, Nat.add_assoc] using h

/--
The last output block is always “clean” because the carry trace is initialized with `κ_K = 0`.

This is the exact formal content of the manuscript’s boundary condition for the generalized-carry
concatenation.
-/
theorem concatWithCarryBlocks_get_last
    (b L baseBlock : ℕ) (ps : List ℕ) (hps : 0 < ps.length) :
    let i : Fin ps.length := ⟨ps.length - 1, Nat.sub_lt hps Nat.one_pos⟩
    (concatWithCarryBlocks b L baseBlock ps).get
        ⟨i.1, by
          have hl : (concatWithCarryBlocks b L baseBlock ps).length = ps.length :=
            concatWithCarryBlocks_length (b := b) (L := L) (baseBlock := baseBlock) ps
          simpa [hl] using i.isLt⟩
      = (baseBlock + ps.get i) % blockBase b L := by
  classical
  intro i
  -- Apply the general “no incoming carry” lemma at the last index.
  refine
    concatWithCarryBlocks_get_of_carryNext_eq_zero (b := b) (L := L) (baseBlock := baseBlock)
      (ps := ps) i ?_
  -- The “next carry” for the last block is the last carry in the trace, which is `0`.
  have hi : i.1 + 1 = ps.length := by
    -- `i.1 = ps.length - 1`, so `i.1 + 1 = ps.length` since `ps.length > 0`.
    simpa [i, Nat.sub_add_cancel (Nat.succ_le_of_lt hps)]
  simpa [hi] using
    (concatWithCarryTrace_carries_get_last_eq_zero (b := b) (L := L) (baseBlock := baseBlock)
      (ps := ps))

/--
If a local block does not overflow and the incoming carry is `0`, then the *outgoing* carry is `0`.

This is the one-step propagation rule behind many “eventually no carries” arguments.
-/
theorem concatWithCarryTrace_carry_get_eq_zero_of_carryNext_get_eq_zero_of_lt_blockBase
    (b L baseBlock : ℕ) (ps : List ℕ) (i : Fin ps.length)
    (hnext :
      let carries := (concatWithCarryTrace b L baseBlock ps).2.2
      carries.get
          ⟨i.1 + 1, by
            have hc : carries.length = ps.length + 1 :=
              concatWithCarryTrace_carries_length (b := b) (L := L) (baseBlock := baseBlock) ps
            simpa [hc] using Nat.succ_lt_succ i.isLt⟩
        = 0)
    (hlt : baseBlock + ps.get i < blockBase b L) :
    let carries := (concatWithCarryTrace b L baseBlock ps).2.2
    carries.get
        ⟨i.1, by
          have hc : carries.length = ps.length + 1 :=
            concatWithCarryTrace_carries_length (b := b) (L := L) (baseBlock := baseBlock) ps
          have hi' : i.1 < ps.length + 1 := Nat.lt_trans i.isLt (Nat.lt_succ_self ps.length)
          simpa [hc] using hi'⟩
      = 0 := by
  classical
  intro carries
  have hcLen : carries.length = ps.length + 1 :=
    concatWithCarryTrace_carries_length (b := b) (L := L) (baseBlock := baseBlock) ps

  -- Index for `i` in the carry list.
  have hiCarry : i.1 < carries.length := by
    have hi' : i.1 < ps.length + 1 := Nat.lt_trans i.isLt (Nat.lt_succ_self ps.length)
    simpa [hcLen] using hi'
  let idx : Fin carries.length := ⟨i.1, hiCarry⟩

  -- Index for `i+1` in the carry list.
  have hiCarryNext : i.1 + 1 < carries.length := by
    simpa [hcLen] using Nat.succ_lt_succ i.isLt
  let idxNext : Fin carries.length := ⟨i.1 + 1, hiCarryNext⟩

  -- Transport `hnext` to the exact `idxNext` we use.
  have hnextIdx : carries.get idxNext = 0 := by
    -- `hnext` is stated with a (potentially) different proof of `i+1 < length`.
    -- But the indices are equal as `Fin` elements, so we can transport.
    have hx : carries.get ⟨i.1 + 1, hiCarryNext⟩ = 0 := by
      -- Rewrite the `let carries := ...` in the hypothesis.
      simpa [carries] using hnext
    simpa [idxNext] using hx

  -- Rewrite the recurrence, then use `hnextIdx`.
  have hcar0 : carries.get idx = (baseBlock + ps.get i + carries.get idxNext) / blockBase b L := by
    -- Unfold the `let carries := ...` inside `concatWithCarryCarries_get`.
    simpa [carries, idx, idxNext, Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using
      (concatWithCarryCarries_get (b := b) (L := L) (baseBlock := baseBlock) (ps := ps) i)

  have hdiv : (baseBlock + ps.get i) / blockBase b L = 0 := by
    simpa [carry] using
      (carry_eq_zero_of_lt_blockBase (b := b) (L := L) (t := baseBlock + ps.get i) hlt)

  -- Finish.
  calc
    carries.get idx
        = (baseBlock + ps.get i + carries.get idxNext) / blockBase b L := hcar0
    _ = (baseBlock + ps.get i + 0) / blockBase b L := by
          -- Rewrite the carry term using `hnextIdx` without fighting proof-irrelevance.
          simpa using
            (congrArg (fun x => (baseBlock + ps.get i + x) / blockBase b L) hnextIdx)
    _ = (baseBlock + ps.get i) / blockBase b L := by simp [Nat.add_assoc]
    _ = 0 := hdiv

/--
If (on good indices) the sums `baseBlock + p_i` do not wrap modulo `B = blockBase b L`, then
injectivity of the residues `((baseBlock + p_i) % B)` reduces to injectivity of the raw
perturbation blocks `p_i`.

This is a convenient way to discharge the `hmod_inj` hypothesis once you know the construction
keeps all good blocks in-range.
-/
theorem mod_inj_of_good_add_lt_blockBase_of_get_inj
    {b L baseBlock : ℕ} {ps : List ℕ}
    (Bad : Finset ℕ)
    (hlt : ∀ (i : Fin ps.length), i.1 ∉ Bad → baseBlock + ps.get i < blockBase b L)
    (hget_inj :
      ∀ (i j : Fin ps.length), i.1 ∉ Bad → j.1 ∉ Bad →
        ps.get i = ps.get j → i.1 = j.1) :
    ∀ (i j : Fin ps.length), i.1 ∉ Bad → j.1 ∉ Bad →
      ((baseBlock + ps.get i) % blockBase b L) = ((baseBlock + ps.get j) % blockBase b L) →
        i.1 = j.1 := by
  intro i j hiBad hjBad hEq
  have hi : (baseBlock + ps.get i) % blockBase b L = baseBlock + ps.get i :=
    Nat.mod_eq_of_lt (hlt i hiBad)
  have hj : (baseBlock + ps.get j) % blockBase b L = baseBlock + ps.get j :=
    Nat.mod_eq_of_lt (hlt j hjBad)
  have hadd : baseBlock + ps.get i = baseBlock + ps.get j := by
    calc
      baseBlock + ps.get i = (baseBlock + ps.get i) % blockBase b L := by
        simpa using hi.symm
      _ = (baseBlock + ps.get j) % blockBase b L := hEq
      _ = baseBlock + ps.get j := by
        simpa using hj
  have hget : ps.get i = ps.get j := Nat.add_left_cancel hadd
  exact hget_inj i j hiBad hjBad hget

/-!
### Turning “no carry on good indices” into `InjOn`-style hypotheses

Your informal reasoning can be cleanly packaged as follows:

* choose a finite set `Bad` of indices (borders, carry-disturbances, witness exceptions);
* assume that for `i ∉ Bad` the incoming carry `κ_{i+1}` is zero;
* assume that the “no-carry formula” values `((baseBlock + p_i) % B)` are injective on those
  good indices.

Then the produced block list `concatWithCarryBlocks ... ps` is injective on good indices in the
exact sense required by the `Word` lemmas in this file.
-/

/--
If (i) there is no incoming carry on good indices, and (ii) the resulting no-carry residues are
injective on good indices, then the output block list is injective on good indices.

This is the clean formal proxy for: “away from borders and carry/witness hazards, the displacement
cannot be counteracted, so equal block values force equal positions”.
-/
theorem concatWithCarryBlocks_hinj_of_goodNoCarry_of_mod_inj
    {b L baseBlock : ℕ} {ps : List ℕ}
    (Bad : Finset ℕ)
    (hcarry0 :
      ∀ (i : Fin ps.length), i.1 ∉ Bad →
        let carries := (concatWithCarryTrace b L baseBlock ps).2.2
        carries[i.1 + 1]'
            (by
              have hc : carries.length = ps.length + 1 :=
                concatWithCarryTrace_carries_length (b := b) (L := L) (baseBlock := baseBlock) ps
              -- `i.1 + 1 < carries.length`.
              simpa [hc] using Nat.succ_lt_succ i.isLt) = 0)
    (hmod_inj :
      ∀ (i j : Fin ps.length), i.1 ∉ Bad → j.1 ∉ Bad →
        ((baseBlock + ps.get i) % blockBase b L) = ((baseBlock + ps.get j) % blockBase b L) →
          i.1 = j.1) :
    ∀ {i j : ℕ}
      (hi : i < (concatWithCarryBlocks b L baseBlock ps).length)
      (hj : j < (concatWithCarryBlocks b L baseBlock ps).length),
        i ∉ Bad → j ∉ Bad →
          (concatWithCarryBlocks b L baseBlock ps).get ⟨i, hi⟩ =
            (concatWithCarryBlocks b L baseBlock ps).get ⟨j, hj⟩ →
              i = j := by
  classical
  intro i j hi hj hiBad hjBad hEq

  have hl : (concatWithCarryBlocks b L baseBlock ps).length = ps.length :=
    concatWithCarryBlocks_length (b := b) (L := L) (baseBlock := baseBlock) ps

  have hi' : i < ps.length := by simpa [hl] using hi
  have hj' : j < ps.length := by simpa [hl] using hj

  let ii : Fin ps.length := ⟨i, hi'⟩
  let jj : Fin ps.length := ⟨j, hj'⟩

  -- Rewrite both sides using the no-carry formula.
  have hget_i :
      (concatWithCarryBlocks b L baseBlock ps).get ⟨i, hi⟩ =
        (baseBlock + ps.get ii) % blockBase b L := by
    have hnext :
        let carries := (concatWithCarryTrace b L baseBlock ps).2.2
        carries[ii.1 + 1]'
            (by
              have hc : carries.length = ps.length + 1 :=
                concatWithCarryTrace_carries_length (b := b) (L := L) (baseBlock := baseBlock) ps
              simpa [hc] using Nat.succ_lt_succ ii.isLt) = 0 :=
      hcarry0 ii (by simpa [ii] using hiBad)
    have hform :=
      concatWithCarryBlocks_get_of_carryNext_eq_zero (b := b) (L := L) (baseBlock := baseBlock)
        (ps := ps) ii hnext
    -- The lemma uses a canonical `Fin` proof for the `get`; switch to our `⟨i,hi⟩`.
    have hx :
        (⟨ii.1, by
            have hl' : (concatWithCarryBlocks b L baseBlock ps).length = ps.length := hl
            simpa [hl'] using ii.isLt⟩ : Fin (concatWithCarryBlocks b L baseBlock ps).length) =
          ⟨i, hi⟩ := by
      ext
      rfl
    simpa [hx, ii] using hform

  have hget_j :
      (concatWithCarryBlocks b L baseBlock ps).get ⟨j, hj⟩ =
        (baseBlock + ps.get jj) % blockBase b L := by
    have hnext :
        let carries := (concatWithCarryTrace b L baseBlock ps).2.2
        carries[jj.1 + 1]'
            (by
              have hc : carries.length = ps.length + 1 :=
                concatWithCarryTrace_carries_length (b := b) (L := L) (baseBlock := baseBlock) ps
              simpa [hc] using Nat.succ_lt_succ jj.isLt) = 0 :=
      hcarry0 jj (by simpa [jj] using hjBad)
    have hform :=
      concatWithCarryBlocks_get_of_carryNext_eq_zero (b := b) (L := L) (baseBlock := baseBlock)
        (ps := ps) jj hnext
    have hx :
        (⟨jj.1, by
            have hl' : (concatWithCarryBlocks b L baseBlock ps).length = ps.length := hl
            simpa [hl'] using jj.isLt⟩ : Fin (concatWithCarryBlocks b L baseBlock ps).length) =
          ⟨j, hj⟩ := by
      ext
      rfl
    simpa [hx, jj] using hform

  have : ((baseBlock + ps.get ii) % blockBase b L) = ((baseBlock + ps.get jj) % blockBase b L) := by
    -- Avoid relying on simp rewriting through `get` notation; do it explicitly.
    calc
      (baseBlock + ps.get ii) % blockBase b L
          = (concatWithCarryBlocks b L baseBlock ps).get ⟨i, hi⟩ := by
              simpa [hget_i] using (Eq.symm hget_i)
      _ = (concatWithCarryBlocks b L baseBlock ps).get ⟨j, hj⟩ := hEq
      _ = (baseBlock + ps.get jj) % blockBase b L := by
            simpa [hget_j] using hget_j

  -- Finish by the assumed injectivity of the no-carry residues.
  exact hmod_inj ii jj (by simpa [ii] using hiBad) (by simpa [jj] using hjBad) this

end BlockModel

namespace BlockModel

/-!
### Few bad indices cannot cover all `p`-spaced pairs

This is a small combinatorial lemma that matches the manuscript intuition:

If only a bounded set of indices can be affected ("bad" indices: carries entering a block,
boundary artifacts, witness exceptions, etc.), then they cannot mask *all* equalities that a
short period would force.

Formally, if `Bad` is small and `len - p` is larger than `2 * Bad.card`, then there exists an
index `i < len - p` such that both `i` and `i+p` are outside `Bad`.

This is the precise pigeonhole/cardiinality step used later as:

`IsPeriod w p` gives `w[i] = w[i+p]` for all `i < len-p`.

Choosing `i` with both indices "good" lets you push that equality through a no-carry lemma.
-/
theorem exists_two_good_indices_of_small_bad
    {len p : ℕ} (hp : p < len) (Bad : Finset ℕ)
    (hcard : 2 * Bad.card < len - p) :
    ∃ i, i < len - p ∧ i ∉ Bad ∧ i + p ∉ Bad := by
  classical
  by_contra h
  have hcover : ∀ i, i < len - p → i ∈ Bad ∨ i + p ∈ Bad := by
    intro i hi
    by_contra h'
    have hiBad : i ∉ Bad := by
      intro hi'
      exact h' (Or.inl hi')
    have hipBad : i + p ∉ Bad := by
      intro hip'
      exact h' (Or.inr hip')
    exact h ⟨i, hi, hiBad, hipBad⟩

  -- If every `i < len - p` is covered by `Bad` or by shifting a `Bad` element left by `p`,
  -- then `range (len-p)` is contained in `Bad ∪ BadShift`.
  let S : Finset ℕ := Finset.range (len - p)
  let BadShift : Finset ℕ := Bad.image (fun j => j - p)

  have hsubset : S ⊆ Bad ∪ BadShift := by
    intro i hiS
    have hi : i < len - p := by
      simpa [S] using (Finset.mem_range.1 hiS)
    rcases hcover i hi with hib | hipb
    · exact Finset.mem_union_left _ hib
    · -- If `i+p ∈ Bad`, then `i = (i+p) - p`, hence `i ∈ BadShift`.
      have : i ∈ BadShift := by
        refine Finset.mem_image.2 ?_
        refine ⟨i + p, hipb, ?_⟩
        -- `(i+p) - p = i`.
        simpa [Nat.add_comm] using (Nat.add_sub_cancel p i)
      exact Finset.mem_union_right _ this

  have hS_card : S.card = len - p := by
    simp [S]
  have hle_union : len - p ≤ (Bad ∪ BadShift).card := by
    -- `card S ≤ card (Bad ∪ BadShift)`.
    have : S.card ≤ (Bad ∪ BadShift).card := Finset.card_le_card hsubset
    simpa [hS_card] using this
  have hle_sum : (Bad ∪ BadShift).card ≤ Bad.card + BadShift.card :=
    Finset.card_union_le Bad BadShift
  have hshift_le : BadShift.card ≤ Bad.card := by
    simpa [BadShift] using (Finset.card_image_le (s := Bad) (f := fun j => j - p))

  have : len - p ≤ 2 * Bad.card := by
    have : len - p ≤ Bad.card + BadShift.card := le_trans hle_union hle_sum
    have : len - p ≤ Bad.card + Bad.card := by
      refine le_trans this ?_
      -- `add_le_add_left` produces `BadShift.card + Bad.card ≤ Bad.card + Bad.card`;
      -- commute the sum on the left.
      have h' : BadShift.card + Bad.card ≤ Bad.card + Bad.card :=
        add_le_add_left hshift_le Bad.card
      simpa [Nat.add_comm] using h'
    simpa [two_mul, Nat.mul_comm, Nat.mul_left_comm, Nat.mul_assoc] using this
  exact (Nat.not_lt_of_ge this) hcard

end BlockModel

namespace Word

/-!
### No subperiod from “few bad indices” + injectivity on good indices

This is the Lean formalization of the reasoning you described:

* a short period `p` would force equalities `w[i] = w[i+p]` for many `i`;
* carries/border effects can only corrupt a small set of indices `Bad`;
* therefore there exists some `i` for which both `i` and `i+p` are *good* (outside `Bad`);
* on good indices, the construction is injective (distinct blocks), so equality is impossible.

We phrase “good-injectivity” directly as a hypothesis about `List.get` at indices outside `Bad`.
-/

theorem not_isPeriod_of_small_bad_of_injOn_good
    {α : Type} {w : List α} {p : ℕ}
    (hp : 0 < p) (hpw : p < w.length)
    (Bad : Finset ℕ)
    (hcard : 2 * Bad.card < w.length - p)
    (hinj :
      ∀ {i j : ℕ} (hi : i < w.length) (hj : j < w.length),
        i ∉ Bad → j ∉ Bad →
          w.get ⟨i, hi⟩ = w.get ⟨j, hj⟩ → i = j) :
    ¬ Word.IsPeriod w p := by
  classical
  intro hper
  rcases BlockModel.exists_two_good_indices_of_small_bad (len := w.length) (p := p) hpw Bad hcard with
    ⟨i, hi, hiBad, hipBad⟩
  have hi_len : i < w.length :=
    lt_of_lt_of_le hi (Nat.sub_le _ _)
  have hip : i + p < w.length := by
    have hp_le : p ≤ w.length := Nat.le_of_lt hpw
    have : i + p < (w.length - p) + p := Nat.add_lt_add_right hi p
    simpa [Nat.sub_add_cancel hp_le] using this
  have heq : w.get ⟨i, hi_len⟩ = w.get ⟨i + p, hip⟩ := hper i hip
  have hij : i = i + p := hinj hi_len hip hiBad hipBad heq
  have hne : i ≠ i + p := ne_of_lt (Nat.lt_add_of_pos_right hp)
  exact hne hij

theorem not_hasSubPeriod_of_small_bad_of_injOn_good
    {α : Type} {w : List α}
    (Bad : Finset ℕ)
    (hinj :
      ∀ {i j : ℕ} (hi : i < w.length) (hj : j < w.length),
        i ∉ Bad → j ∉ Bad →
          w.get ⟨i, hi⟩ = w.get ⟨j, hj⟩ → i = j)
    (hcard : ∀ p : ℕ, 0 < p → p < w.length → 2 * Bad.card < w.length - p) :
    ¬ Word.HasSubPeriod w := by
  classical
  intro hsub
  rcases hsub with ⟨p, hp0, hpw, _hpDiv, hper⟩
  exact
    (not_isPeriod_of_small_bad_of_injOn_good (w := w) (p := p)
      hp0 hpw Bad (hcard p hp0 hpw) hinj) hper

/--
Practical density corollary: if the bad index set has density `< 1/4` (in the crude finitary
sense `4 * card(Bad) < length(w)`), then *no* subperiod can be masked by changing only those bad
indices, as long as the word is injective on good indices.

This matches the “logarithmically bounded carries / bounded border cases cannot simulate a short
period” heuristic: any candidate subperiod `p` must satisfy `p ∣ length`, hence `p ≤ length/2`, so
there are still at least `length-p ≥ length/2` indices forcing period equalities.
-/
theorem not_hasSubPeriod_of_badDensity_lt_quarter_of_injOn_good
    {α : Type} {w : List α}
    (Bad : Finset ℕ)
    (hden : 4 * Bad.card < w.length)
    (hinj :
      ∀ {i j : ℕ} (hi : i < w.length) (hj : j < w.length),
        i ∉ Bad → j ∉ Bad →
          w.get ⟨i, hi⟩ = w.get ⟨j, hj⟩ → i = j) :
    ¬ Word.HasSubPeriod w := by
  classical
  intro hsub
  rcases hsub with ⟨p, hp0, hpw, hpDiv, hper⟩

  -- Turn the density bound into the specific `2*Bad.card < length - p` bound needed for `p`.
  have hp_le_len : p ≤ w.length := Nat.le_of_lt hpw
  rcases hpDiv with ⟨k, hk⟩

  have hk_ge_two : 2 ≤ k := by
    -- If `k = 0` then `length = 0`, contradict `p < length`.
    cases k with
    | zero =>
      have : p < 0 := by
        -- `w.length = p * 0 = 0`
        simpa [hk] using hpw
      exact (False.elim (Nat.not_lt_zero _ this))
    | succ k =>
      cases k with
      | zero =>
        -- `k = 1` gives `length = p`, contradict `p < length`.
        have : p < p := by
          simpa [hk] using hpw
        exact (False.elim (Nat.lt_irrefl _ this))
      | succ k =>
        -- `k = k+2`.
        exact Nat.succ_le_succ (Nat.succ_le_succ (Nat.zero_le k))

  have hp2_le_len : 2 * p ≤ w.length := by
    -- From `length = p * k` and `2 ≤ k`.
    have : p * 2 ≤ p * k := Nat.mul_le_mul_left p hk_ge_two
    -- rewrite into `2*p ≤ length`.
    simpa [hk, Nat.mul_assoc, Nat.mul_left_comm, Nat.mul_comm] using this

  have hp_le_len_sub : p ≤ w.length - p := by
    -- from `p + p ≤ length`.
    have : p + p ≤ w.length := by
      simpa [two_mul] using hp2_le_len
    exact Nat.le_sub_of_add_le this

  have hlen_le_two_sub : w.length ≤ 2 * (w.length - p) := by
    -- `length = (length - p) + p ≤ (length - p) + (length - p)`.
    have : w.length - p + p ≤ w.length - p + (w.length - p) :=
      Nat.add_le_add_left hp_le_len_sub (w.length - p)
    -- rewrite `length - p + p = length`.
    have hsubadd : w.length - p + p = w.length := Nat.sub_add_cancel hp_le_len
    -- rewrite the RHS as `2 * (length - p)`.
    simpa [hsubadd, two_mul, Nat.mul_assoc, Nat.mul_left_comm, Nat.mul_comm] using this

  have hcard : 2 * Bad.card < w.length - p := by
    -- `4*Bad.card < length ≤ 2*(length-p)`.
    have h4 : 4 * Bad.card < 2 * (w.length - p) :=
      lt_of_lt_of_le hden hlen_le_two_sub
    -- Cancel the common factor `2`.
    have : 2 * (2 * Bad.card) < 2 * (w.length - p) := by
      -- `4*Bad.card = 2*(2*Bad.card)`.
      simpa [Nat.mul_assoc, Nat.mul_left_comm, Nat.mul_comm] using h4
    have := (Nat.mul_lt_mul_left (by decide : 0 < 2)).1 this
    simpa [two_mul] using this

  exact (not_isPeriod_of_small_bad_of_injOn_good (w := w) (p := p) hp0 hpw Bad hcard hinj) hper

end Word

namespace BlockModel

/--
Convenience specialization: the output block word `C'` of the generalized-carry concatenation has
no subperiods provided the bad indices have density `< 1/4` and the output word is injective on
good indices.
-/
theorem concatWithCarryBlocks_not_hasSubPeriod_of_badDensity_lt_quarter
    {b L baseBlock : ℕ} {ps : List ℕ}
    (Bad : Finset ℕ)
    (hden : 4 * Bad.card < (concatWithCarryBlocks b L baseBlock ps).length)
    (hinj :
      ∀ {i j : ℕ}
        (hi : i < (concatWithCarryBlocks b L baseBlock ps).length)
        (hj : j < (concatWithCarryBlocks b L baseBlock ps).length),
          i ∉ Bad → j ∉ Bad →
            (concatWithCarryBlocks b L baseBlock ps).get ⟨i, hi⟩ =
              (concatWithCarryBlocks b L baseBlock ps).get ⟨j, hj⟩ → i = j) :
    ¬ Erdos.Word.HasSubPeriod (concatWithCarryBlocks b L baseBlock ps) := by
  simpa using
    (Erdos.Word.not_hasSubPeriod_of_badDensity_lt_quarter_of_injOn_good
      (w := concatWithCarryBlocks b L baseBlock ps) Bad hden hinj)

end BlockModel

end Erdos
